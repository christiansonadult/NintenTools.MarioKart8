// ==== Structures =====================================================================================================

typedef struct // ResFile
{
	char signature[4]; // FRES
	uint version <format=hex, read=VersionRead>;
	ushort byteOrder <format=hex>;
	ushort headerSize <format=hex>; // Only up to alignment.
	uint fileSize;
	uint alignment <format=hex>;
	NameOffset nameOffset;
	uint stringPoolSize;
	uint stringPoolOffset;
	Offset modelDictOffset;
	Offset textureDictOffset;
	Offset skeletalAnimDictOffset;
	Offset shaderParamAnimDictOffset;
	Offset colorAnimDictOffset;
	Offset texSrtAnimDictOffset;
	Offset texPatternAnimDictOffset;
	Offset boneVisAnimDictOffset;
	Offset matVisAnimDictOffset;
	Offset shapeAnimDictOffset;
	Offset sceneAnimDictOffset;
	Offset externalFileDictOffset;
	ushort modelCount;
	ushort textureCount;
	ushort skeletalAnimCount;
	ushort shaderParamAnimCount;
	ushort colorAnimCount;
	ushort texSrtAnimCount;
	ushort texPatternAnimCount;
	ushort boneVisAnimCount;
	ushort matVisAnimCount;
	ushort shapeAnimCount;
	ushort sceneAnimCount;
	ushort externalFileCount;
	uint userPointer;
	// Read main dicts.
	if (modelDictOffset.value)
	{
		FSeek(modelDictOffset.target);
		Dict modelDict(DT_MODEL) <bgcolor=0xBDEBEB>;
	}
	if (textureDictOffset.value)
	{
		FSeek(textureDictOffset.target);
		Dict textureDict(DT_TEXTURE) <bgcolor=0xBDEBEB>;
	}
	if (skeletalAnimDictOffset.value)
	{
		FSeek(skeletalAnimDictOffset.target);
		Dict skeletalAnimDict(DT_SKELETAL_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (shaderParamAnimDictOffset.value)
	{
		FSeek(shaderParamAnimDictOffset.target);
		Dict shaderParamAnimDict(DT_SHADER_PARAM_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (colorAnimDictOffset.value)
	{
		FSeek(colorAnimDictOffset.target);
		Dict colorAnimDict(DT_SHADER_PARAM_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (texSrtAnimDictOffset.value)
	{
		FSeek(texSrtAnimDictOffset.target);
		Dict texSrtAnimDict(DT_SHADER_PARAM_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (texPatternAnimDictOffset.value)
	{
		FSeek(texPatternAnimDictOffset.target);
		Dict texPatternAnimDict(DT_TEX_PATTERN_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (boneVisAnimDictOffset.value)
	{
		FSeek(boneVisAnimDictOffset.target);
		Dict boneVisAnimDict(DT_VISIBILITY_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (matVisAnimDictOffset.value)
	{
		FSeek(matVisAnimDictOffset.target);
		Dict matVisAnimDict(DT_VISIBILITY_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (shapeAnimDictOffset.value)
	{
		FSeek(shapeAnimDictOffset.target);
		Dict shapeAnimDict(DT_SHAPE_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (sceneAnimDictOffset.value)
	{
		FSeek(sceneAnimDictOffset.target);
		Dict sceneAnimDict(DT_SCENE_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (externalFileDictOffset.value)
	{
		FSeek(externalFileDictOffset.target);
		Dict externalFile(DT_EXTERNAL_FILE) <bgcolor=0xBDEBEB>;
	}
} ResFile <bgcolor=0xCDFFFF>;

// ---- Offsets ----

typedef struct // Offset
{
	local uint origin <format=hex> = FTell();
	uint value <format=hex>;
	local uint target <format=hex> = origin + value;
} Offset <read=OffsetRead>;

typedef struct // NameOffset
{
	local uint origin <format=hex> = FTell();
	uint value <format=hex>;
	local uint target <format=hex> = origin + value;
	FSeek(target - sizeof(uint));
	uint nameLength;
	string name;
	FAlign(4);
	FSeek(origin + sizeof(uint));
} NameOffset <read=NameOffsetRead>;

// ---- Dicts ----

typedef struct(DictType type) // Dict
{
	uint size;
	uint nodeCount;
	DictNode nodes[nodeCount + 1] <optimize=false>; // First element is root entry.
	local uint pos <hidden=true> = FTell();
	// Read the entries.
	local int i <hidden=true>;
	for (i = 1; i <= nodeCount; i++)
	{
		FSeek(nodes[i].dataOffset.target);
		switch (type)
		{
			case DT_MODEL: Model model <fgcolor=cNone>; break;
				case DT_BONE: Bone bone <fgcolor=cNone>; break;
				case DT_VERTEX_ATTRIB: VertexAttrib vertexAttrib <fgcolor=cNone>; break;
				case DT_SHAPE: Shape shape <fgcolor=cNone>; break;
				case DT_MATERIAL: Material material <fgcolor=cNone>; break;
					case DT_RENDER_INFO: RenderInfo renderInfo <fgcolor=cNone>; break;
					case DT_SAMPLER: Sampler sampler <fgcolor=cNone>; break;
			case DT_TEXTURE: Texture texture <fgcolor=cNone>; break;
			case DT_SKELETAL_ANIM: SkeletalAnim skeletalAnim <fgcolor=cNone>; break;
			case DT_SHADER_PARAM_ANIM: ShaderParamAnim shaderParamAnim <fgcolor=cNone>; break;
			case DT_TEX_PATTERN_ANIM: TexPatternAnim ftxp <fgcolor=cNone>; break;
			case DT_VISIBILITY_ANIM: VisibilityAnim visibilityAnim <fgcolor=cNone>; break;
			case DT_SHAPE_ANIM: ShapeAnim shapeAnim <fgcolor=cNone>; break;
			case DT_SCENE_ANIM: SceneAnim sceneAnim <fgcolor=cNone>; break;
			case DT_EXTERNAL_FILE: ExternalFile externalFile <fgcolor=cNone>; break;
			case DT_USER_DATA: UserData userData <fgcolor=0x009900>; break;
		}
	}
	FSeek(pos); // Seek back to prevent struct from ending in front of position.
} Dict <fgcolor=0x000099, read=DictRead>;

typedef struct // DictNode
{
	uint key <format=hex>;
	ushort leftIndex;
	ushort rightIndex;
	NameOffset nameOffset;
	Offset dataOffset;
} DictNode <read=DictNodeRead>;

// ---- User Data ----

typedef struct // UserData
{
	NameOffset nameOffset;
	ushort count;
	byte type;
	byte padding <fgcolor=0x808080, hidden=true>;
	switch (type)
	{
		case 0: int value[count]; break;
		case 1: float value[count]; break;
		case 2: string value[count]; break;
		case 3: wstring value[count]; break;
		case 4: byte value[count]; break;
	}
} UserData <fgcolor=0x009900, read=UserDataRead>;

// ==== Template Methods ===============================================================================================

string DictRead(Dict &dict)
{
	string s;
	SPrintf(s, "%d nodes", dict.nodeCount);
	return s;
}

string DictNodeRead(DictNode &dictNode)
{
	if (dictNode.dataOffset.value)
	{
		string s;
		SPrintf(s, "<\"%s\">", dictNode.nameOffset.name);
		return s;
	}
	else
	{
		return "<root>";
	}
}

string NameOffsetRead(NameOffset &nameOffset)
{
	string s;
	SPrintf(s, "%d -> %Xh = %s", nameOffset.value, nameOffset.target, nameOffset.name);
	return s;
}

string OffsetRead(Offset &offset)
{
	string s;
	if (offset.value)
	{
		SPrintf(s, "%d -> %Xh", offset.value, offset.target);
	}
	else
	{
		SPrintf(s, "%d -> N/A", offset.value);
	}
	return s;
}

string UserDataRead(UserData &userData)
{
	// TODO: Show the values.
	return userData.nameOffset.name;
}

string VersionRead(uint version)
{
	string s;
	SPrintf(s, "%Xh (%u.%u.%u.%u)", version,
		version >> 24,
		version >> 16 & 0xFF,
		version >> 8 & 0xFF,
		version & 0xFF);
	return s;
}