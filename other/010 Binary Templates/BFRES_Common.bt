// ==== Structures =====================================================================================================

typedef struct // ResFile
{
	char signature[4]; // FRES
	uint version <format=hex, read=VersionRead>;
	ushort byteOrder <format=hex>;
	ushort headerSize <format=hex>; // Only up to alignment.
	uint fileSize;
	uint alignment <format=hex>;
	NameOffset nameOffset;
	uint stringPoolSize;
	Offset stringPoolOffset;
	Offset modelDictOffset;
	Offset textureDictOffset;
	Offset skeletalAnimDictOffset;
	Offset shaderParamAnimDictOffset;
	Offset colorAnimDictOffset;
	Offset texSrtAnimDictOffset;
	Offset texPatternAnimDictOffset;
	Offset boneVisAnimDictOffset;
	Offset matVisAnimDictOffset;
	Offset shapeAnimDictOffset;
	Offset sceneAnimDictOffset;
	Offset externalFileDictOffset;
	ushort modelCount;
	ushort textureCount;
	ushort skeletalAnimCount;
	ushort shaderParamAnimCount;
	ushort colorAnimCount;
	ushort texSrtAnimCount;
	ushort texPatternAnimCount;
	ushort boneVisAnimCount;
	ushort matVisAnimCount;
	ushort shapeAnimCount;
	ushort sceneAnimCount;
	ushort externalFileCount;
	uint userPointer;
	// Read main dicts.
	if (modelDictOffset.value)
	{
		FSeek(modelDictOffset.target);
		Dict modelDict(DT_MODEL) <bgcolor=0xBDEBEB>;
	}
	if (textureDictOffset.value)
	{
		FSeek(textureDictOffset.target);
		Dict textureDict(DT_TEXTURE) <bgcolor=0xBDEBEB>;
	}
	if (skeletalAnimDictOffset.value)
	{
		FSeek(skeletalAnimDictOffset.target);
		Dict skeletalAnimDict(DT_SKELETAL_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (shaderParamAnimDictOffset.value)
	{
		FSeek(shaderParamAnimDictOffset.target);
		Dict shaderParamAnimDict(DT_SHADER_PARAM_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (colorAnimDictOffset.value)
	{
		FSeek(colorAnimDictOffset.target);
		Dict colorAnimDict(DT_SHADER_PARAM_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (texSrtAnimDictOffset.value)
	{
		FSeek(texSrtAnimDictOffset.target);
		Dict texSrtAnimDict(DT_SHADER_PARAM_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (texPatternAnimDictOffset.value)
	{
		FSeek(texPatternAnimDictOffset.target);
		Dict texPatternAnimDict(DT_TEX_PATTERN_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (boneVisAnimDictOffset.value)
	{
		FSeek(boneVisAnimDictOffset.target);
		Dict boneVisAnimDict(DT_VISIBILITY_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (matVisAnimDictOffset.value)
	{
		FSeek(matVisAnimDictOffset.target);
		Dict matVisAnimDict(DT_VISIBILITY_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (shapeAnimDictOffset.value)
	{
		FSeek(shapeAnimDictOffset.target);
		Dict shapeAnimDict(DT_SHAPE_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (sceneAnimDictOffset.value)
	{
		FSeek(sceneAnimDictOffset.target);
		Dict sceneAnimDict(DT_SCENE_ANIM) <bgcolor=0xBDEBEB>;
	}
	if (externalFileDictOffset.value)
	{
		FSeek(externalFileDictOffset.target);
		Dict externalFile(DT_EXTERNAL_FILE) <bgcolor=0xBDEBEB>;
	}
} ResFile <bgcolor=0xCDFFFF>;

// ---- Offsets ----

typedef struct // Offset
{
	local uint origin <format=hex> = FTell();
	int value;
	if (value)
	{
		local uint target <format=hex> = origin + value;
	}
} Offset <read=OffsetRead>;

typedef struct // NameOffset
{
	local uint origin <format=hex> = FTell();
	int value;
	if (value)
	{
		local uint target <format=hex> = origin + value;
		FSeek(target - sizeof(uint));
		uint nameLength;
		string name;
		FAlign(4);
		FSeek(origin + sizeof(uint));
	}
} NameOffset <read=NameOffsetRead>;

// ---- Dicts ----

typedef struct(DictType type) // Dict
{
	uint size;
	uint nodeCount;
	DictNode nodes[nodeCount + 1] <optimize=false>; // First element is root entry.
	local uint pos <hidden=true> = FTell();
	// Read the entries.
	local int i <hidden=true>;
	for (i = 1; i <= nodeCount; i++)
	{
		if (!nodes[i].dataOffset.value) continue;
		FSeek(nodes[i].dataOffset.target);
		switch (type)
		{
			case DT_MODEL: Model model <fgcolor=cNone>; break;
				case DT_BONE: Bone bone <fgcolor=cNone>; break;
				case DT_VERTEX_ATTRIB: VertexAttrib vertexAttrib <fgcolor=cNone>; break;
				case DT_SHAPE: Shape shape <fgcolor=cNone>; break;
				case DT_MATERIAL: Material material <fgcolor=cNone>; break;
					case DT_RENDER_INFO: RenderInfo renderInfo <fgcolor=cNone>; break;
					case DT_SAMPLER: Sampler sampler <fgcolor=cNone>; break;
			case DT_TEXTURE: Texture texture <fgcolor=cNone>; break;
			case DT_SKELETAL_ANIM: SkeletalAnim skeletalAnim <fgcolor=cNone>; break;
			case DT_SHADER_PARAM_ANIM: ShaderParamAnim shaderParamAnim <fgcolor=cNone>; break;
			case DT_TEX_PATTERN_ANIM: TexPatternAnim texPatternAnim <fgcolor=cNone>; break;
				case DT_TEXTURE_REF: TextureRef textureRef <fgcolor=cNone>; break;
			case DT_VISIBILITY_ANIM: VisibilityAnim visibilityAnim <fgcolor=cNone>; break;
			case DT_SHAPE_ANIM: ShapeAnim shapeAnim <fgcolor=cNone>; break;
			case DT_SCENE_ANIM: SceneAnim sceneAnim <fgcolor=cNone>; break;
				case DT_CAMERA_ANIM: CameraAnim cameraAnim <fgcolor=cNone>; break;
				case DT_LIGHT_ANIM: LightAnim lightAnim <fgcolor=cNone>; break;
				case DT_FOG_ANIM: FogAnim fogAnim <fgcolor=cNone>; break;
			case DT_EXTERNAL_FILE: ExternalFile externalFile <fgcolor=cNone>; break;
				case DT_SHADING_MODEL: ShadingModel shadingModel <fgcolor=cNone>; break;
					case DT_SHADER_OPTION: ShaderOption shaderOption <fgcolor=cNone>; break;
					case DT_ATTRIB_VAR: AttribVar attribVar <fgcolor=cNone>; break;
					case DT_UNIFORM_BLOCK_VAR: UniformBlockVar uniformBlockVar <fgcolor=cNone>; break;
			case DT_USER_DATA: UserData userData <fgcolor=0x009900>; break;
		}
	}
	FSeek(pos); // Seek back to prevent struct from ending in front of position.
} Dict <fgcolor=0x000099, read=DictRead>;

typedef struct // DictNode
{
	uint key <format=hex>;
	ushort leftIndex;
	ushort rightIndex;
	NameOffset nameOffset;
	Offset dataOffset;
} DictNode <read=DictNodeRead>;

// ---- Texture References ----

typedef struct // TextureRef
{
	NameOffset nameOffset;
	Offset textureOffset; // FTEX pointer
} TextureRef <bgcolor=0xBBA1C8, read=TextureRefRead>;

// ---- Animation Curves ----

typedef struct // AnimCurve
{
	ushort flags <format=binary>;
	ushort keyCount;
	uint targetOffset;
	float startFrame;
	float endFrame;
	float dataScale;
	union
	{
		int value;
		float value;
	} dataOffset;
	if (file.version >= 0x03040000)
	{
		float dataDelta;
	}
	Offset frameArrayOffset;
	Offset keyArrayOffset;
	local uint pos <hidden=true> = FTell();
	// Read the frames.
	FSeek(frameArrayOffset.target);
	switch (flags & 0x03) // bits 0,1
	{
		case 0: float frames[keyCount]; break;
		case 1: short frames[keyCount]; break;
		case 2: ubyte frames[keyCount]; break;
	}
	FAlign(4);
	// Read the keys.
	FSeek(keyArrayOffset.target);
	local uint dataSize <hidden=true>;
	switch (flags >> 4 & 0x07) // curveType, bits 4-6
	{
		case 0: dataSize = 4; break;
		case 1: dataSize = 2; break;
		default: dataSize = 1; break;
	}
	switch (flags >> 2 & 0x03) // bits 2,3
	{
		case 0: float data[dataSize * keyCount] <bgcolor=0xC8A1A1, optimize=false>; break;
		case 1: short data[dataSize * keyCount] <bgcolor=0xC8A1A1, optimize=false>; break;
		case 2: ubyte data[dataSize * keyCount] <bgcolor=0xC8A1A1, optimize=false>; break;
	}
	FAlign(4);
	FSeek(pos); // Seek back to header end.	
} AnimCurve <bgcolor=0xD9AEAE>;

// ---- User Data ----

typedef struct // UserData
{
	NameOffset nameOffset;
	ushort count;
	ubyte type;
	ubyte padding <fgcolor=0x808080, hidden=true>;
	switch (type)
	{
		case 0: int value[count]; break;
		case 1: float value[count]; break;
		case 2: Offset value[count]; break; // Points to strings
		case 3: Offset value[count]; break; // Points to UTF8 strings
		case 4: ubyte value[count]; break;
	}
	// TODO: Read textual user data.
} UserData <fgcolor=0x009900, read=UserDataRead>;

// ==== Template Methods ===============================================================================================

string DictRead(Dict &dict)
{
	string s;
	SPrintf(s, "%d nodes", dict.nodeCount);
	return s;
}

string DictNodeRead(DictNode &dictNode)
{
	if (dictNode.nameOffset.value)
	{
		string s;
		SPrintf(s, "<\"%s\">", dictNode.nameOffset.name);
		return s;
	}
	else
	{
		return "<root>";
	}
}

string NameOffsetRead(NameOffset &nameOffset)
{
	string s;
	if (nameOffset.value)
	{
		SPrintf(s, "%d -> %Xh = \"%s\"", nameOffset.value, nameOffset.target, nameOffset.name);
	}
	else
	{
		SPrintf(s, "%d -> N/A", nameOffset.value);
	}
	return s;
}

string OffsetRead(Offset &offset)
{
	string s;
	if (offset.value)
	{
		SPrintf(s, "%d -> %Xh", offset.value, offset.target);
	}
	else
	{
		SPrintf(s, "%d -> N/A", offset.value);
	}
	return s;
}

string TextureRefRead(TextureRef &textureRef)
{
	return textureRef.nameOffset.name;
}

string UserDataRead(UserData &userData)
{
	// TODO: Show the values.
	return userData.nameOffset.name;
}

string VersionRead(uint version)
{
	string s;
	SPrintf(s, "%Xh (%u.%u.%u.%u)", version,
		version >> 24,
		version >> 16 & 0xFF,
		version >> 8 & 0xFF,
		version & 0xFF);
	return s;
}