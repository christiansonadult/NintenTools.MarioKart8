// ==== Structures =====================================================================================================

typedef struct // SkeletalAnim
{
	char signature[4]; // FSKA
	NameOffset nameOffset;
	NameOffset pathOffset;
	uint flags <format=binary>;
	if (file.version >= 0x03040000)
	{
		uint frameCount;
		ushort boneAnimCount;
		ushort userDataCount;
	}
	else
	{
		ushort frameCount;
		ushort boneAnimCount;
		ushort userDataCount;
		ushort padding <fgcolor=0x808080, hidden=true>;
	}
	uint curveCount;
	uint bakedSize;
	Offset boneAnimArrayOffset;
	Offset skeletonOffset; // Points to FSKL
	Offset bindIndexArrayOffset;
	Offset userDataDictOffset;
	// Read bone animations.
	FSeek(boneAnimArrayOffset.target);
	BoneAnim boneAnims[boneAnimCount] <optimize=false>;
	// Read bind indices.
	FSeek(bindIndexArrayOffset.target);
	ushort bindIndices[boneAnimCount] <bgcolor=0xD9AEAE, optimize=true>;
	FAlign(4);
	// Read user data.
	if (userDataDictOffset.value)
	{
		FSeek(userDataDictOffset.target);
		Dict userDataDict(DT_USER_DATA);
	}
} SkeletalAnim <bgcolor=0xFFCDCD, read=SkeletalAnimRead>;

typedef struct // BoneAnim
{
	uint flags <format=binary>;
	NameOffset nameOffset;
	byte beginRotate;
	byte beginTranslate;
	byte animCurveCount;
	byte beginBaseTranslate;
	int beginCurve;
	Offset animCurveArrayOffset;
	Offset baseValueArrayOffset;
	local uint pos <hidden=true> = FTell();
	// Read animation curves.
	if (animCurveCount) // Offset can be valid but count 0.
	{
		FSeek(animCurveArrayOffset.target);
		AnimCurve animCurves[animCurveCount] <optimize=false>;
	}
	// Read base values.
	FSeek(baseValueArrayOffset.target);
	BaseValue baseValue;
	FSeek(pos); // Seek back to header end.	
} BoneAnim <bgcolor=0xEBBDBD, read=BoneAnimRead>;

// ==== Template Methods ===============================================================================================

string SkeletalAnimRead(SkeletalAnim &skeletalAnim)
{
	return skeletalAnim.nameOffset.name;
}

string BoneAnimRead(BoneAnim &boneAnim)
{
	return boneAnim.nameOffset.name;
}
