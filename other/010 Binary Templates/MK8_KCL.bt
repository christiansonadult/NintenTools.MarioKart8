//------------------------------------------------
//--- 010 Editor v8.0.0 Binary Template
//
//      File: MK8_KCL.bt
//   Authors: Syroot
//   Version: 0.5.0
//   Purpose: Nintendo KCL collision model (Mario Kart 8)
//  Category: Software
// File Mask: *.kcl
//  ID Bytes: 20 20 00 00
//   History:
//   0.5.0  2017-05-15  Parse octrees.
//   0.1.0  2016-06-20  Initial version.
//------------------------------------------------

// ---- Structures ----

typedef struct
{
    uint x;
    uint y;
    uint z;
} Vector3 <read=Vector3_Read>;
string Vector3_Read(Vector3& vector3)
{
    string s;
    SPrintf(s, "(%d, %d, %d)", vector3.x, vector3.y, vector3.z);
    return s;
}

typedef struct
{
    float x;
    float y;
    float z;
} Vector3F <read=Vector3F_Read>;
string Vector3F_Read(Vector3F& vector3f)
{
    string s;
    SPrintf(s, "(%.3f, %.3f, %.3f)", vector3f.x, vector3f.y, vector3f.z);
    return s;
}

struct CourseOctreeNode;
struct CourseOctreeNode
{
    uint key <format=hex>;
    switch (key >> 30)
    {
        case 0:
            CourseOctreeNode children[8] <optimize=false>;
            break;
        case 2:
            local uint modelIndex = key & 0x00FFFFFF;
            break;
        case 3:
            break;
    }
};

struct ModelOctreeNode;
struct ModelOctreeNode(uint parentPosition)
{
    uint key <format=hex>;
    local uint offset <hidden=true>; offset = parentPosition + key & 0x3FFFFFFF; // Offset in bytes relative to parent node start.
    local uint oldPos <hidden=true>; oldPos = FTell();
    FSeek(offset);
    if (key >> 31)
    {
        // Node is a leaf and key points to triangle list starting with a separator.
        FSeek(FTell() + 2);
        local ushort lastIndex <hidden=true>;
        while (lastIndex != 0xFFFF)
        {
            ushort triangleIndex;
            lastIndex = triangleIndex;
        }
    }
    else
    {
        // Node is a branch and points to 8 child nodes.
        ModelOctreeNode children(offset)[8] <optimize=false>;
    }
    FSeek(oldPos);
};

struct Triangle
{
    float length;
    ushort positionIndex;
    ushort directionIndex;
    ushort normalAIndex;
    ushort normalBIndex;
    ushort normalCIndex;
    ushort collisionFlags;
    uint globalIndex;
};

struct Model
{
    local uint modelPosition <hidden=true>;
    modelPosition = FTell();

    // Read the header.
    uint positionArrayOffset;
    uint normalArrayOffset;
    uint triangleArrayOffset;
    uint octreeOffset;
    float unknown1;
    Vector3F minCoordinate;
    Vector3 coordinateMask;
    Vector3 coordinateShift;
    float unknown2;

    // Read the positions.
    FSeek(modelPosition + positionArrayOffset);
    Vector3F positions[(normalArrayOffset - positionArrayOffset) / sizeof(Vector3F)] <fgcolor=0x009999>;

    // Read the normals.
    FSeek(modelPosition + normalArrayOffset);
    Vector3F normals[(triangleArrayOffset - normalArrayOffset) / sizeof(Vector3F)] <fgcolor=0x0044FF>;

    // Read the triangles.
    FSeek(modelPosition + triangleArrayOffset);
    Triangle triangles[(octreeOffset - triangleArrayOffset) / sizeof(Triangle)] <fgcolor=0xFF00FF>;

    // Read the octree.
    FSeek(modelPosition + octreeOffset);
    local int nodeCount <hidden=true>; nodeCount
        = ((~coordinateMask.x >> coordinateShift.x) + 1)
        * ((~coordinateMask.y >> coordinateShift.x) + 1)
        * ((~coordinateMask.z >> coordinateShift.x) + 1);
    ModelOctreeNode octree(modelPosition + octreeOffset)[nodeCount] <fgcolor=0xFF0000, optimize=false>;
};

// ---- File Contents ----

BigEndian();

// Read the file header.
uint signature <format=hex, bgcolor=0xAAFFFF>;
uint octreeOffset <format=hex, bgcolor=0xAAFFFF>;
uint modelOffsetArrayOffset <format=hex, bgcolor=0xAAFFFF>;
uint modelCount <bgcolor=0xAAFFFF>;
Vector3F minCoordinate <bgcolor=0xAAFFFF>;
Vector3F maxCoordinate <bgcolor=0xAAFFFF>;
Vector3 coordinateShift <bgcolor=0xAAFFFF>;
uint unknown <bgcolor=0xAAFFFF>;

// Read the model octree.
FSeek(octreeOffset);
CourseOctreeNode globalOctree[8] <bgcolor=0xFFEECC, optimize=false>;

// Read the model offsets.
FSeek(modelOffsetArrayOffset);
uint modelOffsets[modelCount] <bgcolor=0xDDFFDD, format=hex>;

// Read the models.
local int i <hidden=true>;
for (i = 0; i < modelCount; i++)
{
    FSeek(modelOffsets[i]);
    Model models <bgcolor=0xAAFFAA>;
}
