// ==== Structures =====================================================================================================

typedef struct // SkeletalAnim
{
	char signature[4]; // FSKA
	NameOffset nameOffset;
	NameOffset pathOffset;
	uint flags <format=binary>;
	if (file.version >= 0x03040000)
	{
		uint frameCount;
		ushort boneAnimCount;
		ushort userDataCount;
	}
	else
	{
		ushort frameCount;
		ushort boneAnimCount;
		ushort userDataCount;
		ushort padding <fgcolor=0x808080, hidden=true>;
	}
	uint curveCount;
	uint bakedSize;
	Offset boneAnimArrayOffset;
	Offset skeletonOffset; // Points to FSKL
	Offset bindIndexArrayOffset;
	Offset userDataDictOffset;
	// Read bone animations.
	FSeek(boneAnimArrayOffset.target);
	BoneAnim boneAnims[boneAnimCount] <optimize=false>;
	// Read bind indices.
	FSeek(bindIndexArrayOffset.target);
	ushort bindIndices[boneAnimCount] <bgcolor=0xD9AEAE, optimize=true>;
	FAlign(4);
	// Read user data.
	if (userDataDictOffset.value)
	{
		FSeek(userDataDictOffset.target);
		Dict userDataDict(DT_USER_DATA);
	}
} SkeletalAnim <bgcolor=0xFFCDCD, read=SkeletalAnimRead>;

typedef struct // BoneAnim
{
	uint flags <format=binary>;
	NameOffset nameOffset;
	byte beginRotate;
	byte beginTranslate;
	byte animCurveCount;
	byte beginBaseTranslate;
	float beginCurve;
	Offset animCurveArrayOffset;
	Offset baseValueArrayOffset;
	local uint pos <hidden=true> = FTell();
	// Read animation curves.
	if (animCurveCount) // Offset can be valid but count 0.
	{
		FSeek(animCurveArrayOffset.target);
		AnimCurve animCurves[animCurveCount] <optimize=false>;
	}
	// Read base values.
	FSeek(baseValueArrayOffset.target);
	BaseValue baseValue;
	FSeek(pos); // Seek back to header end.	
} BoneAnim <bgcolor=0xEBBDBD, read=BoneAnimRead>;

typedef struct // AnimCurve
{
	ushort flags <format=binary>;
	ushort keyCount;
	uint targetOffset;
	float startFrame;
	float endFrame;
	float dataScale;
	float dataOffset;
	if (file.version >= 0x03040000)
	{
		float dataDelta;
	}
	Offset frameArrayOffset;
	Offset keyArrayOffset;
	local uint pos <hidden=true> = FTell();
	// Read the frames.
	FSeek(frameArrayOffset.target);
	switch (flags & 0x03) // bits 0,1
	{
		case 0: float frames[keyCount]; break;
		case 1: short frames[keyCount]; break;
		case 2: ubyte frames[keyCount]; break;
	}
	FAlign(4);
	// Read the keys.
	FSeek(keyArrayOffset.target);
	AnimCurveKey keys(flags, keyCount)[keyCount] <optimize=true>;
	FSeek(pos); // Seek back to header end.	
} AnimCurve <bgcolor=0xD9AEAE>;

typedef struct(ushort flags, ushort keyCount) // AnimCurveKey
{
	local uint dataSize <hidden=true>;
	switch (flags >> 4 & 0x07) // curveType, bits 4-6
	{
		case 0: dataSize = 4; break;
		case 1: dataSize = 2; break;
		default: dataSize = 1; break;
	}
	switch (flags >> 2 & 0x03) // bits 2,3
	{
		case 0: float data[dataSize * keyCount] <optimize=true>; break;
		case 1: short data[dataSize * keyCount] <optimize=true>; break;
		case 2: ubyte data[dataSize * keyCount] <optimize=true>; break;
	}
} AnimCurveKey <bgcolor=0xC8A1A1>;

typedef struct // BaseValue
{
	Vector3F scaling;
	Vector4F rotation;
	Vector3F position;
} BaseValue <bgcolor=0xD9AEAE>;

// ==== Template Methods ===============================================================================================

string SkeletalAnimRead(SkeletalAnim &skeletalAnim)
{
	return skeletalAnim.nameOffset.name;
}

string BoneAnimRead(BoneAnim &boneAnim)
{
	return boneAnim.nameOffset.name;
}
